/* -*- mode: C; c-basic-offset: 4; intent-tabs-mode: nil -*-
 *
 * STIR -- Sifteo Tiled Image Reducer
 * M. Elizabeth Scott <beth@sifteo.com>
 *
 * Copyright <c> 2011 Sifteo, Inc. All rights reserved.
 */

#include "cppwriter.h"
#include "audioencoder.h"
#include <assert.h>

namespace Stir {

const char *CPPWriter::indent = "    ";

CPPWriter::CPPWriter(Logger &log, const char *filename)
    : mLog(log)
{
    if (filename) {
        mStream.open(filename);
        if (!mStream.is_open())
            log.error("Error opening output file '%s'", filename);
    }
    
    if (mStream.is_open())
        head();
}

void CPPWriter::head()
{
    mStream <<
        "/*\n"
        " * Generated by STIR. Do not edit by hand.\n"
        " */\n"
        "\n"
        "#include <sifteo/asset.h>\n";
}

void CPPWriter::foot()
{}
 
void CPPWriter::close()
{
    if (mStream.is_open()) {
        foot();
        mStream.close();
    }
}

void CPPWriter::writeString(const std::vector<uint8_t> &data)
{
    // Write a large uint8_t array, as a string literal. This is handled
    // more efficiently by the compiler than a large array, so the resulting
    // code compiles quickly. The downside: resulting code is very ugly!

    unsigned i = 0;
    
    do {
        unsigned lineLength = 2;
        mStream << "\"";

        while (i < data.size() && lineLength < 120) {
            uint8_t byte = data[i++];

            if (byte >= ' ' && byte <= '~' && byte != '"' && byte != '\\' && byte != '?') {
                mStream << (char)byte;
                lineLength++;
            } else {
                mStream << '\\'
                    << (char)('0' + (byte >> 6))
                    << (char)('0' + ((byte >> 3) & 7))
                    << (char)('0' + (byte & 7));
                lineLength += 4;
            }
        }

        mStream << "\"\n";
    } while (i < data.size());
}

void CPPWriter::writeArray(const std::vector<uint8_t> &data)
{
    char buf[8];
    mStream << indent;
    for (unsigned i = 0; i < data.size(); i++) {
        if (i && !(i % 16))
            mStream << "\n" << indent;
        sprintf(buf, "0x%02x,", data[i]);
        mStream << buf;
    }
    mStream << "\n";
}

void CPPWriter::writeArray(const std::vector<uint16_t> &data)
{
    char buf[8];
    mStream << indent;
    for (unsigned i = 0; i < data.size(); i++) {
        if (i && !(i % 8))
            mStream << "\n" << indent;
        sprintf(buf, "0x%04x,", data[i]);
        mStream << buf;
    }
    mStream << "\n";
}

CPPSourceWriter::CPPSourceWriter(Logger &log, const char *filename)
    : CPPWriter(log, filename) {}

void CPPSourceWriter::writeGroup(const Group &group)
{
    char hash[32];

#ifdef __MINGW32__
    sprintf(hash, "0x%016I64x", (long long unsigned int) group.getHash());
#else
    sprintf(hash, "0x%016llx", (long long unsigned int) group.getHash());
#endif

    mStream <<
        "\n"
        "static const struct {\n" <<
        indent << "struct _SYSAssetGroupHeader hdr;\n" <<
        indent << "uint8_t data[" << group.getLoadstream().size() << "];\n"
        "} " << group.getName() << "_data = {{\n" <<
        indent << "/* hdrSize   */ sizeof(struct _SYSAssetGroupHeader),\n" <<
        indent << "/* reserved  */ 0,\n" <<
        indent << "/* numTiles  */ " << group.getPool().size() << ",\n" <<
        indent << "/* dataSize  */ " << group.getLoadstream().size() << ",\n" <<
        indent << "/* hash      */ " << hash << ",\n"
        "}, {\n";

    writeArray(group.getLoadstream());

    mStream <<
        "}};\n\n"
        "Sifteo::AssetGroup " << group.getName() << " = {{\n" <<
        indent << "/* pHdr      */ reinterpret_cast<uint32_t>(&" << group.getName() << "_data.hdr),\n" <<
        "}};\n\n";

    mLog.infoBegin("Encoding images");
    for (std::set<Image*>::iterator i = group.getImages().begin();
         i != group.getImages().end(); i++)
        writeImage(**i);
    mLog.infoEnd();
}

void CPPSourceWriter::writeSound(const Sound &sound)
{
    std::vector<uint8_t> data;
    AudioEncoder *enc = AudioEncoder::create(sound.getEncode(), sound.getQuality(), sound.getVBR());
    assert(enc != 0);

    float kbps;
    enc->encodeFile(sound.getFile(), data, kbps);
    mLog.infoLineWithLabel(sound.getName().c_str(),
        "%7.02f kiB, %6.02f kbps %s (%s)",
        data.size() / 1024.0f, kbps, enc->getName(), sound.getFile().c_str());

    if (data.empty())
        mLog.error("Error encoding audio file '%s'", sound.getFile().c_str());

    mStream << "static const char " << sound.getName() << "_data[] = \n";
    writeString(data);
    mStream << ";\n\n";

    mStream <<
        "extern const Sifteo::AssetAudio " << sound.getName() << " = {{\n" <<
        indent << "/* type      */ " << enc->getTypeSymbol() << ",\n" <<
        indent << "/* reserved0 */ " << 0 << ",\n" <<
        indent << "/* reserved1 */ " << 0 << ",\n" <<
        indent << "/* dataSize  */ " << data.size() << ",\n" <<
        indent << "/* pData     */ reinterpret_cast<uint32_t>(" << sound.getName() << "_data),\n" <<
        "}};\n\n";

    delete enc;
}

void CPPSourceWriter::writeImage(const Image &image)
{
    const std::vector<TileGrid> &grids = image.getGrids();
    unsigned width = grids.empty() ? 0 : grids[0].width();
    unsigned height = grids.empty() ? 0 : grids[0].height();

    // Declare the data so we can do a forward reference,
    // to keep the header ordered first in memory when we can.
    mStream << "extern const uint16_t " << image.getName() << "_data[];\n";

    // This header can often be optimized out by slinky, unless its address is taken.
    // Here we output just the common non-format-specific header.
    mStream <<
        "\n"
        "extern const Sifteo::" << image.getClassName() << " " << image.getName() << " = {{\n" <<
        indent << "/* group    */ reinterpret_cast<uint32_t>(&" << image.getGroup()->getName() << "),\n" <<
        indent << "/* width    */ " << width << ",\n" <<
        indent << "/* height   */ " << height << ",\n" <<
        indent << "/* frames   */ " << grids.size() << ",\n";

    bool isSingleTile = width == 1 && height == 1 && grids.size() == 1;
    if (image.isPinned() || isSingleTile) {
        mStream <<
            indent << "/* format   */ _SYS_AIF_PINNED,\n" <<
            indent << "/* reserved */ 0,\n" <<
            indent << "/* data     */ " << image.encodePinned() << "\n}};\n\n";
        return;
    }
    
    // If we aren't explicitly writing a Flat asset, try to compress it
    if (!image.isFlat()) {
        std::vector<uint16_t> data;
        std::string format;
        if (image.encodeDUB(data, mLog, format)) {
            mStream <<
                indent << "/* format   */ " << format << ",\n" <<
                indent << "/* reserved */ 0,\n" <<
                indent << "/* data     */ reinterpret_cast<uint32_t>(" << image.getName() << "_data)\n}};\n\n" <<
                "const uint16_t " << image.getName() << "_data[] = {\n";
            writeArray(data);
            mStream << "};\n\n";
            return;
        }
    }

    // Fall back on a Flat (uncompressed tile array) asset. Note that we only
    // wrap this in a FlatAssetImage class if the script explicitly requested
    // a flat asset. If we decided not to compress an asset with default params,
    // it will still be in an AssetImage class, but the compression format will
    // be _SYS_AIF_FLAT.

    mStream <<
        indent << "/* format   */ _SYS_AIF_FLAT,\n" <<
        indent << "/* reserved */ 0,\n" <<
        indent << "/* data     */ reinterpret_cast<uint32_t>(" << image.getName() << "_data)\n}};\n\n" <<
        "const uint16_t " << image.getName() << "_data[] = {\n";
    std::vector<uint16_t> data;
    image.encodeFlat(data);
    writeArray(data);
    mStream << "};\n\n";
}

CPPHeaderWriter::CPPHeaderWriter(Logger &log, const char *filename)
    : CPPWriter(log, filename)
{
    if (filename)
        createGuardName(filename);

    if (mStream.is_open())
        head();
}

void CPPHeaderWriter::createGuardName(const char *filename)
{
    /*
     * Make a name for the include guard, based on the filename
     */

    char c;
    char prev = '_';
    guardName = prev;

    while ((c = *filename)) {
        c = toupper(c);

        if (isalpha(c)) {
            prev = c;
            guardName += prev;
        } else if (prev != '_') {
            prev = '_';
            guardName += prev;
        }

        filename++;
    }
}

void CPPHeaderWriter::head()
{
    mStream <<
        "\n"
        "#ifndef " << guardName << "\n"
        "#define " << guardName << "\n"
        "\n";
}

void CPPHeaderWriter::foot()
{
    mStream <<
        "\n"
        "#endif  // " << guardName << "\n";

    CPPWriter::foot();
}

void CPPHeaderWriter::writeGroup(const Group &group)
{
    mStream << "extern Sifteo::AssetGroup " << group.getName() << ";\n";

    for (std::set<Image*>::iterator i = group.getImages().begin();
         i != group.getImages().end(); i++) {
        Image *image = *i;
        mStream << "extern const Sifteo::" << image->getClassName() << " " << image->getName() << ";\n";
    }
}

void CPPHeaderWriter::writeSound(const Sound &sound)
{
    mStream << "extern const Sifteo::AssetAudio " << sound.getName() << ";\n";
}

};  // namespace Stir
