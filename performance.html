<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Sifteo SDK: Performance</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-style-overrides.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<center>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Sifteo SDK" src="sdk_logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">v1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</center>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Guides</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Performance </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Tips and best practices for performance optimization</p>
<h1>Introduction</h1>
<p>The <a class="el" href="execution_env.html">Execution Environment</a> used by Sifteo Cubes is fairly resource constrained, meaning that most games will at some point have to face performance optimization challenges. If you're used to optimizing C++ code on a small portable platform, many of those skills will serve you well in optimizing Sifteo applications as well. But in many ways this is a very unique platform. This guide covers many of the specific optimization techniques for Sifteo Cubes.</p>
<p>There are four types of common bottlenecks:</p>
<ul>
<li>Flash Bandwidth</li>
<li>CPU</li>
<li>Graphics</li>
<li>Radio</li>
</ul>
<p>Let's cover each one individually.</p>
<h1>Flash Bandwidth</h1>
<p>This is a common bottleneck on the Sifteo cubes, so it deserves some detailed attention. Since the the Base has such a tiny execution environment, it must be "fed" code and static data in small chunks from external Flash memory. And of course, the bandwidth used to make these transfers is limited, so it's easy to choke if you are paging lots of code.</p>
<p>The primary tool to reduce the load is a small 16K cache. By keeping your code small enough to fit in this cache most of the time, you can reduce the load on flash bandwidth and make the cubes sing!</p>
<p>The best way to optimize here is adopt a style of code that lends itself to fitting within your cache. These rules all boil down to keeping code <em>linear</em> as much as possible. If we spend the time to page in a block of code, as much of that code as possible should be relevant to the current gameplay. Time spent paging in <em>dead</em> code is wasted time.</p>
<p>So how does one code to maximize the cache?</p>
<ul>
<li>Code directly, do not create many layers of runtime indirection.</li>
<li>Use compile-time abstraction (for example, inline functions) instead of runtime abstraction (i.e. virtual functions)</li>
<li>Prefer modal functions over highly object-oriented designs.</li>
<li>Avoid intermediate data formats. Generate static data in the form that the machine accepts it.</li>
<li>Data that will be referenced very frequently and/or very randomly can be copied to RAM first.</li>
<li>Don't jump around in code a lot, keep it local.</li>
<li>Consider decompressing tile data into a <a class="el" href="struct_sifteo_1_1_tile_buffer.html" title="A drawable that&#39;s backed by plain memory, instead of by a VideoBuffer. ">Sifteo::TileBuffer</a> or <a class="el" href="struct_sifteo_1_1_relocatable_tile_buffer.html" title="A drawable that&#39;s backed by plain memory, usable with multiple cubes. ">Sifteo::RelocatableTileBuffer</a> and drawing that.</li>
<li>Think carefully about using lookup tables. Consider whether it may be faster to use a switch statement, or to copy that table to RAM.</li>
<li>Use masks to quickly iterate over "all entities that do X" as opposed to entering functions that do the check "is entity X" and immediately returning. The <a class="el" href="class_sifteo_1_1_bit_array.html" title="A fixed-size array of bits, with compact storage and fast iteration. ">Sifteo::BitArray</a> class and its iterator has this operation built-in.</li>
</ul>
<p>This last point encourages a practice called Data-Oriented Design. In summary, learn to process your updates based on the type of data it uses instead of its logical hierarchy. For example, don't do this:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;for (Entity e : entites)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    if (e.IsRoom())</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;        e.ProcessRoom();</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    else if (e.IsView())</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        e.ProcessView();</div>
</div><!-- fragment --><p>Instead, do something like this:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;for (Entity e : ListRooms(entities))</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    e.ProcessRoom();</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;for (Entity e : ListViews(entities))</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    e.ProcessView();</div>
</div><!-- fragment --><p>The trick is to build BitArrays that can quickly tell you which entities need which types of updates. The ARM processor in the base has a handy-dandy instruction called CLZ (Count Leading Zeroes) that makes this kind of iteration super fast.</p>
<p>There are two main source of metrics to determine how well you are utilizing the flash cache. Running in siftulator with the &ndash;svm-flash-stats option will log cache hits and misses. There are also <a class="el" href="scripting.html">Lua hooks</a> for catching flash misses programmatically.</p>
<p>So what are some techniques to better utilize the cache?</p>
<ul>
<li>Write smaller functions.</li>
<li>Hunt down flash misses, and examine why you are missing.</li>
<li>Avoid heavy functions that do early-outs. The goal is code linearity!</li>
<li>Check assembly to see what's really going on.</li>
<li>Use <a class="el" href="group__memory.html#ga81b5bc3aea892b0062149ef79b49804b" title="memcpy(), with an implicit 8-bit data width ">memcpy()</a> whenever you can. This is the most efficient way to copy data out of flash.</li>
<li>Write code to model "what the player is doing" instead of going for hierarchical object-oriented design.</li>
</ul>
<h1>CPU</h1>
<p>Most Sifteo games are not CPU bound. Flash bandwidth and graphics performance are much more common sources of slowness. But still, watch out for types of operations that place a large load on the CPU:</p>
<ul>
<li>High sample rates in tracker audio</li>
<li>Poorly-written game logic</li>
<li>Decompressing data from flash:</li>
<li>Heavy floating-point math</li>
<li>Unnecessary memory loads and stores</li>
</ul>
<h2>Decompression bottlenecks</h2>
<p>There are several places where the system may spend CPU time to decompress data from flash:</p>
<ul>
<li>Decompressing AssetImages</li>
<li>Decompressing ADPCM audio</li>
<li>Invoking other runtime decompression, such as FastLZ1.</li>
</ul>
<p>Normally these are not bottlenecks, but if they do become too much of a CPU burden, you may be able to selectively disable compression on the problematic data (such as by using FlatAssetImage or uncompressed PCM audio), or you can pre-decompress it (i.e. by storing images in a TileBuffer).</p>
<h2>Floating point math bottlenecks</h2>
<p>The Base's CPU has no hardware floating point coprocessor. It is super fast at integer math, even at integer multiplication. But floating point will always be a bit pokey.</p>
<p>For human-timescale operations, such as animation that happens once or a few times per frame, this shouldn't be a problem. But if you have any inner loops or very math-heavy algorithms, consider avoiding floating point in those cases, and using integer math or fixed-point instead.</p>
<p>In particular, math library functions like <a class="el" href="group__math.html#gaf9c3188aeeb64b61d3769108a0c845cd" title="Calculate the sine of a specified angle, in radians. Single-precision. ">sin()</a>, <a class="el" href="group__math.html#gac2d6750df5f8e49a1170b8f681502b13" title="Calculate the cosine of a specified angle, in radians. Single-precision. ">cos()</a>, <a class="el" href="group__math.html#ga20311b4dc8c3af67579a2517c36e2e4e" title="Compute the square root of a floating point number. Single-precision. ">sqrt()</a>, and <a class="el" href="group__math.html#ga4c75549406b0cd0f1c3751641740f668" title="Compute the natural log of a floating point number. Single-precision. ">log()</a> are especially slow. When possible, avoid these operations or pre-compute the values you need.</p>
<p>If you're using trig heavily but you don't need amazing precision, consider the table-driven alternatives: <a class="el" href="group__math.html#ga652bc802d1b4491b90a1172f8d7e628b" title="Table-driven drop-in replacement for sin() ">tsin()</a> and <a class="el" href="group__math.html#gadd2bea115d12a254d0532c86fd247eb7" title="Table-driven drop-in replacement for cos() ">tcos()</a>, or their fixed-point counterparts <a class="el" href="group__math.html#ga26d92e54204a9ca8e496a930b3402ad4" title="Integer sine table lookup. ">tsini()</a> and <a class="el" href="group__math.html#gae3e036d15ed47bf3514d19f9796e76ee" title="Integer cosine table lookup. ">tcosi()</a>.</p>
<p>Remember, integer math is very fast! Integer math runs at full native speed in SVM, without either the software floating point overhead itself, or the virtualization overhead inherent in calling into the floating point library.</p>
<p>Pro Tip! Use <a class="el" href="class_sifteo_1_1_time_delta.html" title="Represents a difference between two SystemTimes, with moderate resolution. ">Sifteo::TimeDelta</a> for frame time delta instead of floats. Floats are convenient, but beyond that it's rarely a good idea to use them for time.</p>
<h2>Memory load/store bottlenecks</h2>
<p>Due to details of the SVM architecture, some types of memory are vastly speedier than others:</p>
<ul>
<li>General purpose registers are extremely fast</li>
<li>Local variables in a non-oversized stack frame are almost as fast</li>
<li>Local variables in an oversized stack frame are somewhat slower</li>
<li>Any other kind of RAM is a little slower still</li>
<li>Uncached flash memory is very slow</li>
</ul>
<p>The compiler will naturally try to keep things in fast memory whenever possible, but due to the semantics of memory access in C++ it isn't always possible for the compiler to optimize out loads and stores. So it can help the optimizer to keep data in local variables instead of repeatedly accessing class members.</p>
<ul>
<li>Use local variables for temporary space, not class member variables</li>
<li>In some cases, it may be faster to <a class="el" href="group__memory.html#ga81b5bc3aea892b0062149ef79b49804b" title="memcpy(), with an implicit 8-bit data width ">memcpy()</a> a data structure to the stack, manipulate it there, then <a class="el" href="group__memory.html#ga81b5bc3aea892b0062149ef79b49804b" title="memcpy(), with an implicit 8-bit data width ">memcpy()</a> it back.</li>
</ul>
<h1>Graphics</h1>
<p>Along with flash bandwidth, graphics performance is the other common bottleneck in Sifteo games. The graphic engine is distributed to maximize performance, but you have to keep in mind what it's doing in order to not get in it's way.</p>
<p>So what are some techniques to optimize graphics?</p>
<ul>
<li><b>Eliminate overdraw</b>. This is really important, and we discuss it separately below.</li>
<li>Try moving sprites (it's cheap!). Also BG0 and BG1 panning.</li>
<li>Do not change masks or tiles every frame.</li>
<li>Think carefully about what you are asking the graphics pipeline to do, and unnecessary operations like early System::finish().<ul>
<li>Note that finish calls near the end of the frame often are "free" if the rendering has already completed.</li>
</ul>
</li>
</ul>
<p>Cubes do not render synchronously, but certain function calls (namely System::finish) can force them to wait and sync up. Some types of rendering require this behavior, but it is also easy to call finish more often than you need to. Also watch out for functions that implicitly call finish like VideoBuffer::initMode and BG1Drawable::setMask. Only call finish when you need it (for example, before some dependent BG1 calls).</p>
<h2>Overdraw</h2>
<p>In this case, <em>overdraw</em> refers to any situation where you're drawing data to a <a class="el" href="struct_sifteo_1_1_video_buffer.html" title="A memory buffer which holds graphics data. ">Sifteo::VideoBuffer</a> which is different from the final content you intend the VideoBuffer to contain at the end of the frame.</p>
<p>For example, this operation causes overdraw:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// Overdraw! AVOID THIS!</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;vid.bg0.image(vec(0,0), Background);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;vid.bg0.image(vec(4,2), Door);</div>
</div><!-- fragment --><p>If you were do to this every frame (which itself is probably a bad idea if this screen is not changing) you would be repeatedly marking the Door's tiles as <em>changed</em>, causing them to go out over the radio every frame, and the cube to continuously re-draw the screen.</p>
<p>You can tell if this is happening by looking at the frame rate counter under each cube in Siftulator. If it shows a nonzero FPS count even when the scene is idle, you're probably causing overdraw. This will waste radio bandwidth and waste battery power!</p>
<p>Additionally, overdraw can cause <b>flickering</b>. If we happen to send the contents of the VideoBuffer over the radio between these two draws, the cube will momentarily show the background but not the door, causing the door to flicker. These types of bugs are often highly timing-dependent, and it's common for them to be visible in hardware but not in simulation, or vice versa.</p>
<p>There are multiple ways to solve overdraw:</p>
<ul>
<li>Draw to a <a class="el" href="struct_sifteo_1_1_tile_buffer.html" title="A drawable that&#39;s backed by plain memory, instead of by a VideoBuffer. ">Sifteo::TileBuffer</a> or <a class="el" href="struct_sifteo_1_1_relocatable_tile_buffer.html" title="A drawable that&#39;s backed by plain memory, usable with multiple cubes. ">Sifteo::RelocatableTileBuffer</a> as a "back-buffer", then copy that to the VideoBuffer.</li>
<li>Slice your drawing so that each tile is painted at most once per frame. For example, the above example could draw the Background in four separate slices, with a 'cutout' where the Door will go.</li>
<li>Invert your rendering operations. Instead of visiting each object from back-to-front and painting those objects, visit each tile of the screen and decide what should be shown at that location. This approach is especially effective when you're implementing a scrolling graphics engine which needs to update arbitrary small slices of the screen.</li>
</ul>
<p>If you have the memory to spare, double-buffering is usually the easiest way around overdraw. For example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// Using a TileBuffer to avoid overdraw</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;TileBuffer&lt;16,16&gt; buffer;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;buffer.image(vec(0,0), Background);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;buffer.image(vec(4,2), Door);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;vid.bg0.image(vec(0,0), buffer);</div>
</div><!-- fragment --><h1>Radio</h1>
<p>Radio communication between the base and cubes can also be a bottleneck. However, this is rare since the system is designed to minimize radio transmissions. But watch out if you are continuously transmitting data (for example, with non-stop changing of frame buffer mode pixels).</p>
<p>You can take a peek at radio traffic using the siftulator option &ndash;radio-trace. The format is not documented, but you can see how many packets are going to what cubes and how full those packets are.</p>
<p>So what can you do to optimize radio traffic?</p>
<ul>
<li>Eradicate any overdraw. This is the #1 enemy of radio bandwidth.</li>
<li>If you're scrolling, make use of panning and modulo arithmetic in order to keep from "moving" large amounts of data around in the VideoBuffer. Keep your tiles put, and use panning to move the layer around.</li>
<li>It's much more efficient to copy data from nearby in the VideoBuffer than it is to send completely new data, if that's possible. The compression codec will look for copyable tiles above and to the left of tiles that are being encoded. Copies do not need to be exact- we can also copy tiles and add a small delta to them.</li>
<li>In FB32 mode, use even-numbered color indices primarily. Data words with bit 0 and bit 8 set to zero compress much better in our radio protocol. </li>
</ul>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
    <hr class="footer"/>
    <address class="footer">
        <p><a href="http://sifteo.com">Sifteo</a> SDK v1.1.0 <small>(see <a href="https://developers.sifteo.com/archive">all versions</a>)</small></p>
        <p>Last updated Tue Dec 23 2014, by <a href="http://www.stack.nl/~dimitri/doxygen">Doxygen</a></p>
    </address>
</body>
</html>
