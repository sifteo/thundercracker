/*
 * Thundercracker Firmware -- Confidential, not for redistribution.
 * Copyright <c> 2012 Sifteo, Inc. All rights reserved.
 */

#include "audiomixer.h"
#include "audiooutdevice.h"
#include "flash_blockcache.h"
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include "xmtrackerplayer.h"
#include "volume.h"
#include "machine.h"
#include "pause.h"

#ifdef SIFTEO_SIMULATOR
#   include "system.h"
#   include "system_mc.h"
#   include "mc_audiovisdata.h"
#else
#   include "sampleprofiler.h"
#endif

// Lookup table generated by tools/firmware-audiolimit-table.py
#include "audiolimit-table.def"


AudioMixer AudioMixer::instance;
AudioMixer::OutputBuffer AudioMixer::output;


AudioMixer::AudioMixer() :
    lastSample(0),
    fadeStep(0),
    trackerCallbackInterval(0),
    trackerCallbackCountdown(0),
    playingChannelMask(0),
    numSilentSamples(output.capacity() + 1)
{
    // Fill the buffer with silence
    output.fill(AudioOutDevice::getSampleBias());
}

void AudioMixer::init()
{
    fadeOut();
    while (!outputBufferIsSilent())
        Tasks::work();

    output.init();

    uint32_t mask = playingChannelMask;
    while (mask) {
        unsigned idx = Intrinsic::CLZ(mask);
        mask &= ~Intrinsic::LZ(idx);

        if (idx >= _SYS_AUDIO_MAX_CHANNELS) {
            ASSERT(idx < _SYS_AUDIO_MAX_CHANNELS);
            continue;
        }

        AudioChannelSlot &ch = channelSlots[idx];

        ch.stop();
    }

    XmTrackerPlayer::instance.init();
}

ALWAYS_INLINE bool AudioMixer::mixAudio(int *buffer, uint32_t numFrames)
{
    /*
     * Mix audio from flash into the audio device's buffer via each of the channels.
     *
     * This currently assumes that it's being run on the main thread, such that it
     * can operate synchronously with data arriving from flash.
     *
     * Returns true if any audio data was available. If so, we're guaranteed
     * to produce exactly 'numFrames' of data.
     *
     * Assumes the buffer was already zero'ed. Each channel is mixed together
     * into the same buffer.
     *
     * If buffer is NULL, we update the state of all channels without
     * actually generating any audio data.
     */
    
    bool result = false;

    uint32_t mask = playingChannelMask;
    while (mask) {
        unsigned idx = Intrinsic::CLZ(mask);
        mask ^= Intrinsic::LZ(idx);
        ASSERT(idx < _SYS_AUDIO_MAX_CHANNELS);

        AudioChannelSlot &ch = channelSlots[idx];

        if (ch.isStopped()) {
            Atomic::ClearLZ(playingChannelMask, idx);
            continue;
        }
        if (ch.isPaused()) {
            continue;
        }
        
        // Each channel individually mixes itself with the existing buffer contents
        result |= ch.mixAudio(buffer, numFrames);
    }
    
    return result;
}

ALWAYS_INLINE int AudioMixer::softLimiter(int32_t sample)
{
    /*
     * This is a stateless soft limiter, which cuts a few corners to achieve
     * the lowest CPU load we can get.
     *
     * We don't perform any feedback or feed-forward, we just map 'sample'
     * from 32-bit to 16-bit using a nonlinear transfer function that has been
     * precalculated and stored as a lookup table.
     *
     * This lookup table gives us a fixed-point gain value. To save time, we
     * don't interpolate these gain values. These quantized gains are multiplied
     * by the full-resolution input sample to yield our actual output sample.
     *
     * The gain curve is calculated ahead-of-time by tools/firmware-audiolimit-table.py
     *
     * Performance notes:
     *   - Int return value is faster than int16, since we avoid unnecessary sign-extend
     *   - The original implementation used a peak tracker and linear interpolation.
     *     This didn't signiciantly improve the output, and the cycles-per-sample cost
     *     was too high.
     *   - Currently this compiles to 9 instructions. Keep an eye on the disassembly!
     */

    // Instantaneous peak power
    uint32_t peak = Intrinsic::abs(sample);

    /*
     * Calculate a table index for the limiter. These values are power-of-two,
     * so it should boil down to a single bit shift. Our table should have plenty
     * of dynamic range, so we don't need to worry about behaving correctly if the
     * input exceeds it.
     */
    const unsigned divisor = 0x8000 * AudioLimitMaxPeak / AudioLimitSteps;
    STATIC_ASSERT(divisor > 0);
    STATIC_ASSERT((divisor & (divisor - 1)) == 0);  // Power of two
    STATIC_ASSERT(AudioLimitSteps == arraysize(AudioLimitTable));
    STATIC_ASSERT((AudioLimitSteps & (AudioLimitSteps - 1)) == 0);
    unsigned index = (peak / divisor) & (AudioLimitSteps - 1);
    ASSERT(index < AudioLimitSteps);

    // Look up gain for this power value
    int gain = AudioLimitTable[index];
    int attenuated = (sample * gain) >> 16;

    ASSERT(attenuated >= -0x8000);
    ASSERT(attenuated <=  0x7FFF);
    return attenuated;
}

/*
 * Called from within Tasks::work to mix audio on the main thread, to be
 * consumed by the audio out device.
 */
void AudioMixer::pullAudio()
{
    /*
     * Support audio in Siftulator, even in headless mode.
     *
     * In headless mode, we want to continue mixing even though
     * there's no buffer attached or no space in that buffer. We'll
     * either discard the mixed data, or if a waveout file is set we'll
     * end up logging the mixed audio data.
     */

    #ifdef SIFTEO_SIMULATOR
        const bool headless = SystemMC::getSystem()->opt_headless;
    #else
        const bool headless = false;
    #endif

    AudioMixer &mixer = AudioMixer::instance;

    /*
     * Early out when we can quickly determine that no channels are playing
     * and the tracker is idle.
     *
     * Note that in headless mode, we have no audio driver to wake up our
     * task, we're polling based on wallclock time: so we constantly re-trigger
     * our own task. In other modes, we do NOT do this. We only wake up when
     * the audio driver has dequeued some samples.
     */

    #ifdef SIFTEO_SIMULATOR
        if (headless) {
            Tasks::trigger(Tasks::AudioPull);
        }
    #endif

    #ifdef SIFTEO_SIMULATOR
        MCAudioVisData::instance.mixerActive = mixer.active();
    #endif

    if (!mixer.active()) {

        // must give simulated audio device a chance to pull any
        // data already in the mix buffer, even if all channels have emptied
        if (!headless) {
            AudioOutDevice::pullFromMixer();
        }

        if (mixer.trackerCallbackInterval == 0)
            return;
    }

    /*
     * In order to amortize the cost of iterating over channels, our
     * audio mixer operates on small arrays of samples at a time. We
     * give it a tiny buffer on the stack, which then flushes out
     * to the device's provided AudioBuffer.
     *
     * We're responsible for invoking the Tracker's callback
     * deterministically, exactly every 'trackerInterval' samples.
     * To do this, we may need to subdivide the blocks we request
     * from mixAudio(), or we may need to generate silent blocks.
     *
     * We refuse to pull (exiting early) if there are too few samples
     * to mix, so that we don't destroy our amortization gains by
     * mixing one sample at a time.
     */

    int blockBuffer[32];
    unsigned samplesLeft = output.writeAvailable();

    #ifdef SIFTEO_SIMULATOR
        if (headless) {
            samplesLeft = SystemMC::suggestAudioSamplesToMix();
        }
    #endif

    if (samplesLeft < arraysize(blockBuffer)) {
        // Need more room in the buffer before we can mix!
        if (!headless)
            AudioOutDevice::pullFromMixer();
        return;
    }

    #ifndef SIFTEO_SIMULATOR
        SampleProfiler::SubSystem s = SampleProfiler::subsystem();
        SampleProfiler::setSubsystem(SampleProfiler::AudioPull);
    #endif

    const uint32_t trackerInterval = mixer.trackerCallbackInterval;
    uint32_t trackerCountdown;

    if (trackerInterval == 0) {
        // Tracker callbacks disabled. Avoid special-casing below by
        // assuming a countdown value that's effectively infinite.
        trackerCountdown = 0x10000;
    } else {
        trackerCountdown = mixer.trackerCallbackCountdown;
        ASSERT(trackerCountdown != 0 && "Countdown should never be stored as zero when the timer is enabled");
    } 

    // Calculating volume is relatively expensive; do it only if we have audio to mix.
    const int mixerVolume = Volume::systemVolume();
    ASSERT(mixerVolume >= 0 && mixerVolume <= Volume::MAX_VOLUME);

    #ifdef SIFTEO_SIMULATOR
        /*
         * Reserve one slot for an end-of-stream token in simulation.
         * Because the mix loop may continue after the stream has ended
         * (ie, to keep ticking the tracker's clock), ensure we only
         * send the first end-of-stream that we see.
         */
        samplesLeft--;
        bool endOfStreamSet = false;
    #endif

    // Some devices are signed, some are unsigned. The bias value lets us cover both cases.
    int sampleBias = AudioOutDevice::getSampleBias();

    do {
        bool mixed;
        uint32_t blockSize = MIN(arraysize(blockBuffer), samplesLeft);
        blockSize = MIN(blockSize, trackerCountdown);
        ASSERT(blockSize > 0);

        if (mixer.fadeStep) {

            /*
             * We're fading out.
             *
             * A simple linear fade to avoid clicks. This is required when
             * we need to pause audio globally before it reaches end of stream
             * on its own, either as a result of pausing or quitting a game.
             *
             * Typically, callers will tell us to fadeOut() and then monitor
             * outputBufferIsSilent() to determine whether we're done.
             */

            mixed = mixer.lastSample;

            for (int *i = blockBuffer, *e = blockBuffer + blockSize; i != e; ++i) {
                *i = mixer.lastSample;

                if (mixer.lastSample) {
                    // ensure last sample is aligned to our FADE_INCREMENT
                    ASSERT((mixer.lastSample & FADE_TEST) == 0);
                    mixer.lastSample -= mixer.fadeStep;
                }
            }

            if (mixer.outputBufferIsSilent()) {
                mixer.fadeStep = 0;
                return;
            }

        } else if (mixerVolume) {
            // Not muted. Generate audio data

            // Zero out the buffer (Faster than memset)
            for (int *i = blockBuffer, *e = blockBuffer + blockSize; i != e; ++i)
                *i = 0;

            // Mix data from all channels.
            mixed = mixer.mixAudio(blockBuffer, blockSize);
            // save our latest sample in the event that we need to begin a fadeout
            mixer.lastSample = blockBuffer[blockSize - 1];

        } else {
            /*  
             * Disable mixing if the output is muted, both to save a little power
             * and to make audio performance bugs easier to diagnose.
             *
             * We still need to go into each channel's mixer in order to update
             * channel state, but this inhibits the expensive decompression and
             * mixing operations from occurring.
             */

            mixer.mixAudio(0, blockSize);
            mixed = false;
        }

        if (mixed) {
            // Output buffer no longer silent
            mixer.numSilentSamples = 0;
        } else {
            /*
             * The mixer had nothing for us? Normally this means
             * we can early-out and let the device's buffer drain,
             * but if we're running the tracker, we need to keep
             * samples flowing in order to keep its clock advancing.
             *
             * Generate silence, and remember that we've done so. If we
             * fill the buffer with silence, we can do an early-out next time.
             */

            mixer.numSilentSamples += blockSize;

            #ifdef SIFTEO_SIMULATOR
            if (!headless) {
                if (!endOfStreamSet) {
                    output.enqueue(AudioOutDevice::END_OF_STREAM);
                    endOfStreamSet = true;
                }
            }
            #endif

            if (trackerInterval == 0 && mixer.outputBufferIsSilent()) {
                // No need to store these zero samples.
                break;
            }
        }

        trackerCountdown -= blockSize;
        samplesLeft -= blockSize;

        /*
         * Finish mixing our block of audio, by applying the system-wide
         * volume control and clamping to 16 bits.
         *
         * We do this even if muted (as long as tracker audio is running)
         * so there's a consistent time-base, based on the audio clock's
         * rate of consuming silent samples.
         */

        int *ptr = blockBuffer;
        do {
            /*
             * In one step, this does a fixed-point multiply with the mixer volume and by
             * the overall mixer gain constant. The result is a 32-bit signed value.
             */
            int sample = (*(ptr++) * (mixerVolume >> 1))
                >> (Volume::MAX_VOLUME_LOG2 - 1 - Volume::MIXER_GAIN_LOG2);

            // Use the soft limiter to convert back to 16-bit samples.
            int16_t sample16 = softLimiter(sample);

            #ifdef SIFTEO_SIMULATOR
                // Log audio for --waveout
                SystemMC::logAudioSamples(&sample16, 1);
            #endif

            if (!headless) {
                output.enqueue(sample16 + sampleBias);
            }

        } while (--blockSize);

        if (!trackerCountdown) {
            ASSERT(trackerInterval);
            trackerCountdown = trackerInterval;
            XmTrackerPlayer::mixerCallback();
        }

    } while (samplesLeft);

    if (trackerInterval != 0) {
        // Write back local copy of Countdown, only if it's real.
        mixer.trackerCallbackCountdown = trackerCountdown;
    }

    // Give the output a chance to dequeue data immediately (Only used on Siftulator)
    if (!headless)
        AudioOutDevice::pullFromMixer();

    #ifndef SIFTEO_SIMULATOR
        SampleProfiler::setSubsystem(s);
    #endif
}

bool AudioMixer::play(const struct _SYSAudioModule *mod,
    _SYSAudioChannelID ch, _SYSAudioLoopType loopMode)
{
    // NB: "mod" is a temporary contiguous copy of _SYSAudioModule in RAM.

    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return false;
    }

    // Already playing?
    if (isPlaying(ch))
        return false;

    AudioChannelSlot &slot = channelSlots[ch];
    slot.play(mod, loopMode);
    Atomic::SetLZ(playingChannelMask, ch);

    return true;
}

bool AudioMixer::isPlaying(_SYSAudioChannelID ch) const
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return false;
    }

    return (playingChannelMask & Intrinsic::LZ(ch)) != 0;
}

void AudioMixer::stop(_SYSAudioChannelID ch)
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return;
    }

    channelSlots[ch].stop();
    Atomic::ClearLZ(playingChannelMask, ch);

    #ifdef SIFTEO_SIMULATOR
        MCAudioVisData::clearChannel(ch);
    #endif
}

void AudioMixer::pause(_SYSAudioChannelID ch)
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return;
    }

    if (isPlaying(ch)) {
        channelSlots[ch].pause();
    }

    #ifdef SIFTEO_SIMULATOR
        MCAudioVisData::clearChannel(ch);
    #endif
}

void AudioMixer::resume(_SYSAudioChannelID ch)
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return;
    }

    if (isPlaying(ch)) {
        channelSlots[ch].resume();
    }
}

void AudioMixer::setVolume(_SYSAudioChannelID ch, uint16_t volume)
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return;
    }

    channelSlots[ch].setVolume(volume);
}

int AudioMixer::volume(_SYSAudioChannelID ch) const
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return -1;
    }

    return channelSlots[ch].volume;
}

void AudioMixer::setSpeed(_SYSAudioChannelID ch, uint32_t samplerate)
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return;
    }

    channelSlots[ch].setSpeed(samplerate);
}

void AudioMixer::setPos(_SYSAudioChannelID ch, uint32_t ofs)
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return;
    }

    channelSlots[ch].setPos(ofs);
}

uint32_t AudioMixer::pos(_SYSAudioChannelID ch) const
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return (uint32_t)-1;
    }

    // TODO - implement
    return 0;
}

void AudioMixer::setLoop(_SYSAudioChannelID ch, _SYSAudioLoopType loopMode)
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return;
    }

    channelSlots[ch].setLoop(loopMode);
}

void AudioMixer::setTrackerCallbackInterval(uint32_t usec)
{
    static const uint64_t kMicroSecondsPerSecond = 1000000;

    // Convert to frames
    trackerCallbackInterval = ((uint64_t)usec * (uint64_t)SAMPLE_HZ) / kMicroSecondsPerSecond;

    // Catch underflow. No one should ever need callbacks this often. Ever.
    ASSERT(usec == 0 || trackerCallbackInterval > 0);
    // But if we're not DEBUG, we may as well let it happen every sample. Gross.
    if (usec > 0 && trackerCallbackInterval == 0) {
        trackerCallbackInterval = 1;
    }

    trackerCallbackCountdown = trackerCallbackInterval;
}
