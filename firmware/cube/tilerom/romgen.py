#!/usr/bin/env python
#
# Generator script for ROM tileset.
# M. Elizabeth Scott <beth@sifteo.com>
# 
# Copyright (c) 2011 Sifteo, Inc.
#

import Image
import os.path
import struct

TILE = 8
MAX_TILES = 1 << 9
MAX_INDEX = 1 << 14


def RGB565(r, g, b):
    # Round to the nearest 5/6 bit color. Note that simple
    # bit truncation does NOT produce the best result!

    r5 = (r * 31 + 128) // 255;
    g6 = (g * 63 + 128) // 255;
    b5 = (b * 31 + 128) // 255;
    return (r5 << 11) | (g6 << 5) | b5


class Tiler:
    def __init__(self):
        self.tiles = []
        self.memo = {}

    def loadPalette(self, filename):
        self.palette = tuple(Image.open(filename).getdata())
        if len(self.palette) != 16 * 4:
            raise ValueError("Must have exactly 16 palettes, of 4 colors each")

    def loadTiles(self, filename):
        image = Image.open(filename)
        width, height = image.size

        if (width % TILE) or (height % TILE):
            raise ValueError("Map size %dx%d pixels is not a multiple of our %d pixel tile-size"
                             % (width, height, self.tileSize))
        width /= TILE
        height /= TILE

        for y in range(height):
            for x in range(width):
                self.loadTile(tuple(image.crop((x * TILE, y * TILE,
                                                (x+1) * TILE, (y+1) * TILE)).getdata()))

        if len(self.tiles) > MAX_TILES:
            raise ValueError("Out of room in the tile map (%d tiles found, max is %d)"
                             % (len(self.tiles), MAX_TILES))

        # Unused tiles are reserved with all '1' bits, equivalent to blank flash memory.
        # This means we can still program those tiles later if we need to.
        while len(self.tiles) < MAX_TILES:
            self.tiles.append((1,) * (TILE * TILE))

    def loadTile(self, pixels):
        if 2 in pixels or 3 in pixels:
            self.loadTile4Color(pixels)
        else:
            self.loadTile2Color(pixels)
    
    def loadTile2Color(self, pixels):
        # This tile has one plane, and that plane can occur anywhere in memory.
        # Add it sequentially, and remember that we have this tile. If this tile
        # has occurred anywhere else (even as one plane from a 4-color tile) we can
        # omit it.

        if pixels not in self.memo:
            self.memo[pixels] = True
            self.tiles.append(pixels)

    def loadTile4Color(self, pixels):
        # We can skip this tile if the exact same 4-color tile has occurred already,
        # but otherwise we must always add both planes consecutively. Note that we
        # memoize both the 4-color version of this tile and each of its 2-color
        # planes.

        if pixels not in self.memo:
            self.memo[pixels] = True
            for plane in (tuple([x & 1 for x in pixels]),
                          tuple([x >> 1 for x in pixels])):
                self.tiles.append(plane)
                self.memo[plane] = True

    def renderTile(self, index):
        # Render a tile image, given its 14-bit index

        palBase = ((index >> 9) & 0xF) << 2
        mode = (index >> 13) & 1
        address = index & 0x1FF

        tile = Image.new("RGB", (TILE, TILE))
        for i in xrange(TILE*TILE):
            x = i % TILE
            y = i / TILE

            if mode:
                if (address & 0x7F) == 0x7F:
                    # DPL roll-over behavior is not defined.
                    # In our current implementation this will cause an advancement by one
                    # scanline, but apps shoudln't rely on that behaviour. So, this is a reserved
                    # index. Mark it as blank in the atlas.
                    index = 0
                else:
                    index = self.tiles[address][i] | (self.tiles[address + 1][i] << 1)
            else:
                index = self.tiles[address][i]

            tile.putpixel((x, y), self.palette[palBase + index])
    
        return tile

    def saveAtlas(self, filename):
        width = 128
        height = MAX_INDEX / width
        image = Image.new("RGB", (width*TILE, height*TILE))

        for y in range(height):
            for x in range(width):
                image.paste(self.renderTile(x + y*width),
                            (x*TILE, y*TILE))

        image.save(filename)

    def saveCode(self, filename):
        open(filename, 'w').write("""
/* -*- mode: C; c-basic-offset: 4; intent-tabs-mode: nil -*-
 *
 * Tile ROM for Thundercracker cube firmware.
 * This file is AUTOMATICALLY GENERATED by romgen.py
 *
 * Copyright <c> 2011 Sifteo, Inc. All rights reserved.
 */

#include <stdint.h>

/*
 * This is the last 4K + 128 bytes of the code ROM. If there's a bug
 * that causes us to read past the end of rom_tiles, we really don't
 * want to allow anyone to read back our (secret) firmware ROM.
 *
 * rom_tiles[] must be located on a 256-byte boundary.
 */

const __code __at (0x2f80) uint8_t rom_palettes[] = {
%s};

const __code __at (0x3000) uint8_t rom_tiles[] = {
%s};
""".lstrip() % (self.cByteArray(self.swizzlePalette(self.paletteBytes())),
                self.cByteArray(self.swizzleTiles(self.tileBytes()))))

    def cByteArray(self, bytes, width=16, indent="    "):
        # Format a list of byte values as a C array

        parts = []
        for i, b in enumerate(bytes):
            if (i % width) == 0:
                parts.append(indent)
            parts.append("0x%02x," % b)
            if (i % width) == width - 1 or i == len(bytes) - 1:
                parts.append("\n")
        return ''.join(parts)

    def paletteBytes(self):
        bytes = []
        for color in self.palette:
            value = RGB565(*color)
            bytes.append(value & 0xFF)
            bytes.append(value >> 8)
        return bytes

    def tileBytes(self):
        bytes = []
        for tile in self.tiles:
            for y in range(TILE):
                byte = 0
                for x in range(TILE):
                    if tile[x + y*TILE]:
                        byte |= 1 << x
                bytes.append(byte)
        return bytes

    # Swizzling:
    #
    # Since we're free to choose the addressing scheme for these arrays
    # to be anything we want, and there's no reason to access them in order,
    # we choose an arrangement which is optimized to allow the graphics loops
    # to make as few calculations as possible. In particular, we really try
    # hard to avoid bit shifting, since there's no fast way to do it on the
    # 8051. This means taking advantage of bits in their existing alignment
    # within the byte we found them in.

    def swizzlePalette(self, bytes):
        # Address swizzling for palette:
        #    0ppp pbcc -> 0ppp pccb       

        return [bytes[ (i & 0xF8) |
                       ((i & 3) << 1) |
                       ((i & 4) >> 2) ] for i in range(len(bytes))]

    def swizzleTiles(self, bytes):
        # Address swizzling for tiles:
        #    0000 lttl tttt tttl -> 0000 tttt tttt tlll

        return [bytes[ ((i & 0x0600) << 1) |
                       ((i & 0x00FE) << 2) |
                       ((i & 0x0800) >> 9) |
                       ((i & 0x0100) >> 7) |
                       ((i & 0x0001) )] for i in range(len(bytes))]


if __name__ == "__main__":
    t = Tiler()
    t.loadPalette("tilerom/src-palettes.png")
    t.loadTiles("tilerom/src-tiles.png")
    t.saveAtlas("tilerom/tilerom-atlas.png")
    t.saveCode("tilerom.c")
