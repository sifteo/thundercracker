#!/usr/bin/env python
"""
SVM syscall renumbering utility.

This is for use *only* during development, before the ABI has been frozen.
We renumber all syscalls, using a variety of heuristics to do so:

  - The most common syscalls are assigned to fast-access slots 0-63
  - Some syscalls, for implementation reasons, must have specific numbers.
  - Everything else being equal, we assign in the order they appear in abi.h

usage: renumber-syscalls.py /path/to/abi.h calls.txt

  - calls.txt is a text file in which the last token of each
    line is an integer syscall number. This can be generated by various
    means, including the DUMP_SYSCALLS hack in Slinky plus grep. It is
    mined for call frequency information. This file refers to the current
    syscall numbers in abi.h.

  - A new version of abi.h, with different numbering, is written to stdout.

M. Elizabeth Scott <beth@sifteo.com>
Copyright <c> 2012 Sifteo, Inc. All rights reserved.

"""

import sys, re

# Number of reserved slots to leave open in the fast-access area
RESERVED_SLOTS = 16

# Hardcoded syscall numbers
FIXED_NUMBERS = {
    'abort': 0,
    }

# Syscalls that must *not* be in the lower 64, due to event dispatch.
HIGH_SYSCALLS = [
    'yield',
    'paint',
    'finish',
    ]

FN_REGEX = re.compile(r"^.*_SYS_(\w+)\s*\(.*\)\s+_SC\((\d+)\)");
NUMBER_REGEX = re.compile(r"_SC\((\d+)\)");


def collectSyscallFreq(freqFilename):
    # Calculates the frequencies of all syscalls, and sorts them in
    # increasing order of frequency. Returns a list of syscall numbers.

    bins = {}

    for line in open(freqFilename):
        tokens = line.split()
        if tokens:
            num = int(tokens[-1])
            bins[num] = bins.get(num, 0) + 1

    freq = bins.items()
    freq.sort(lambda a,b: cmp(a[1],b[1]))
    return [num for num, count in freq]


def collectSyscalls(abiHeader):
    # Returns a mapping from old number to name, and a list of names.

    map = {}
    names = []
    for line in open(abiHeader):
        m = FN_REGEX.match(line)
        if m:
            names.append(m.group(1))
            map[int(m.group(2))] = m.group(1)
        elif NUMBER_REGEX.search(line):
            raise Exception("Regex might have missed a syscall on line: %r" % line);
    return map, names


def generateHeader(abiHeader, map):
    # Print a new version of abi.h, with the syscall numbers replaced.

    for line in open(abiHeader):
        line = line.rstrip()
        m = FN_REGEX.match(line)
        if m:
            line = NUMBER_REGEX.sub("_SC(%d)" % map[m.group(1)], line)
        print line


def nextAvailable(map):
    # Find the next available numeric value in 'map'.
    values = map.values()
    n = 0
    while n in values:
        n += 1
    return n


def main(abiFilename, freqFilename):
    numFreq = collectSyscallFreq(freqFilename)
    nameMap, nameList = collectSyscalls(abiFilename)

    # Start out with the hardcoded numbers assigned
    newNumbers = dict(FIXED_NUMBERS)
    
    # Reserve the reserved slots
    for i in range(RESERVED_SLOTS):
        n = nextAvailable(newNumbers)
        assert n < 64
        newNumbers["reserved_%d" % i] = n

    # Fill the rest of the fast-access slots with the most frequent calls
    while nextAvailable(newNumbers) < 64 and numFreq:
        name = nameMap[numFreq.pop()]
        if name not in newNumbers and name not in HIGH_SYSCALLS:
            newNumbers[name] = nextAvailable(newNumbers)

    # Now fill the rest in, in order
    for name in nameList:
        if name not in newNumbers:
            newNumbers[name] = nextAvailable(newNumbers)

    # Output a new abi.h
    generateHeader(abiFilename, newNumbers)


if __name__ == "__main__":
    if len(sys.argv) != 3:
        sys.stderr.write(__doc__)
        sys.exit(1)

    main(*sys.argv[1:])
