<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Sifteo SDK: Sifteo::UsbQueue&lt; tCapacity &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-style-overrides.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<center>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Sifteo SDK" src="sdk_logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">v1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</center>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="pages.html"><span>Guides</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Sifteo</b></li><li class="navelem"><a class="el" href="struct_sifteo_1_1_usb_queue.html">UsbQueue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="struct_sifteo_1_1_usb_queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Sifteo::UsbQueue&lt; tCapacity &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__usb.html">USB</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A memory buffer which holds a queue of USB packets.  
 <a href="struct_sifteo_1_1_usb_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="usb_8h_source.html">sifteo/usb.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a669dea9220267cf28ad8811a4030b6eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a669dea9220267cf28ad8811a4030b6eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sifteo_1_1_usb_queue.html#a669dea9220267cf28ad8811a4030b6eb">clear</a> ()</td></tr>
<tr class="memdesc:a669dea9220267cf28ad8811a4030b6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes this queue's header, and marks it as empty. <br /></td></tr>
<tr class="separator:a669dea9220267cf28ad8811a4030b6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210ba397133bb0eeb95500953b2ca899"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sifteo_1_1_usb_queue.html#a210ba397133bb0eeb95500953b2ca899">commit</a> ()</td></tr>
<tr class="memdesc:a210ba397133bb0eeb95500953b2ca899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish writing a packet that was started with <a class="el" href="struct_sifteo_1_1_usb_queue.html#a9a5cadbf7029711fec8899246687ff2c" title="Access a buffer slot where a new packet can be written. ">reserve()</a>  <a href="#a210ba397133bb0eeb95500953b2ca899">More...</a><br /></td></tr>
<tr class="separator:a210ba397133bb0eeb95500953b2ca899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d82e5efa4c12532b24a8384309efade"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d82e5efa4c12532b24a8384309efade"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sifteo_1_1_usb_queue.html#a9d82e5efa4c12532b24a8384309efade">empty</a> () const </td></tr>
<tr class="memdesc:a9d82e5efa4c12532b24a8384309efade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the queue empty? <br /></td></tr>
<tr class="separator:a9d82e5efa4c12532b24a8384309efade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29aa8097a7a10d54dfab21279c8ea858"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29aa8097a7a10d54dfab21279c8ea858"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sifteo_1_1_usb_queue.html#a29aa8097a7a10d54dfab21279c8ea858">full</a> () const </td></tr>
<tr class="memdesc:a29aa8097a7a10d54dfab21279c8ea858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the queue full? <br /></td></tr>
<tr class="separator:a29aa8097a7a10d54dfab21279c8ea858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9064ba3d92d5d871a0c39fab1ea18c2b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_sifteo_1_1_usb_packet.html">UsbPacket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sifteo_1_1_usb_queue.html#a9064ba3d92d5d871a0c39fab1ea18c2b">peek</a> () const </td></tr>
<tr class="memdesc:a9064ba3d92d5d871a0c39fab1ea18c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the oldest queued packet without copying it.  <a href="#a9064ba3d92d5d871a0c39fab1ea18c2b">More...</a><br /></td></tr>
<tr class="separator:a9064ba3d92d5d871a0c39fab1ea18c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47942c80131d658ef477f026da9d553e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sifteo_1_1_usb_queue.html#a47942c80131d658ef477f026da9d553e">pop</a> ()</td></tr>
<tr class="memdesc:a47942c80131d658ef477f026da9d553e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue the oldest packet.  <a href="#a47942c80131d658ef477f026da9d553e">More...</a><br /></td></tr>
<tr class="separator:a47942c80131d658ef477f026da9d553e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa5f04ad70ffc4bce177962a4b85c8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sifteo_1_1_usb_queue.html#acfa5f04ad70ffc4bce177962a4b85c8b">read</a> (<a class="el" href="struct_sifteo_1_1_usb_packet.html">UsbPacket</a> &amp;buffer)</td></tr>
<tr class="memdesc:acfa5f04ad70ffc4bce177962a4b85c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the oldest queued packet into a provided buffer.  <a href="#acfa5f04ad70ffc4bce177962a4b85c8b">More...</a><br /></td></tr>
<tr class="separator:acfa5f04ad70ffc4bce177962a4b85c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5cadbf7029711fec8899246687ff2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sifteo_1_1_usb_packet.html">UsbPacket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sifteo_1_1_usb_queue.html#a9a5cadbf7029711fec8899246687ff2c">reserve</a> ()</td></tr>
<tr class="memdesc:a9a5cadbf7029711fec8899246687ff2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a buffer slot where a new packet can be written.  <a href="#a9a5cadbf7029711fec8899246687ff2c">More...</a><br /></td></tr>
<tr class="separator:a9a5cadbf7029711fec8899246687ff2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ea7fde0ddb1c4a1ea8fceb0b53f25f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sifteo_1_1_usb_queue.html#ad9ea7fde0ddb1c4a1ea8fceb0b53f25f">write</a> (const <a class="el" href="struct_sifteo_1_1_usb_packet.html">UsbPacket</a> &amp;buffer)</td></tr>
<tr class="memdesc:ad9ea7fde0ddb1c4a1ea8fceb0b53f25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a new packet into the queue, from a provided buffer.  <a href="#ad9ea7fde0ddb1c4a1ea8fceb0b53f25f">More...</a><br /></td></tr>
<tr class="separator:ad9ea7fde0ddb1c4a1ea8fceb0b53f25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;unsigned tCapacity&gt;<br />
struct Sifteo::UsbQueue&lt; tCapacity &gt;</h3>

<p>A memory buffer which holds a queue of USB packets. </p>
<p>This is a FIFO buffer which holds packets that the game has created but is waiting to transmit, or packets which have been received by the system but not yet processed by the game.</p>
<p>This is a single-producer single-consumer lock-free queue. Typically your application is either a producer or a consumer, communicating via this queue with system software that runs in the background.</p>
<p>UsbQueues are templatized by buffer size. The system supports buffers with between 1 and 255 packets of capacity. You can pick a buffer size based on how many packets you expect may arrive between each opportunity you have to check on the queue.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tCapacity</td><td>The maximum number of packets this queue can buffer. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a210ba397133bb0eeb95500953b2ca899"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned tCapacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_sifteo_1_1_usb_queue.html">Sifteo::UsbQueue</a>&lt; tCapacity &gt;::commit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish writing a packet that was started with <a class="el" href="struct_sifteo_1_1_usb_queue.html#a9a5cadbf7029711fec8899246687ff2c" title="Access a buffer slot where a new packet can be written. ">reserve()</a> </p>
<p>When this function finishes, the new packet will be visible to consumers on this queue. </p>

</div>
</div>
<a class="anchor" id="a9064ba3d92d5d871a0c39fab1ea18c2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned tCapacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_sifteo_1_1_usb_packet.html">UsbPacket</a>&amp; <a class="el" href="struct_sifteo_1_1_usb_queue.html">Sifteo::UsbQueue</a>&lt; tCapacity &gt;::peek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the oldest queued packet without copying it. </p>
<p>Must only be called if readAvailable() returns a nonzero value. If no packets are available, try again later or use an Event to get notified when USB data arrives.</p>
<p>This returns a reference to the oldest queued packet in the buffer. This can be used to inspect a packet before <a class="el" href="struct_sifteo_1_1_usb_queue.html#acfa5f04ad70ffc4bce177962a4b85c8b" title="Read the oldest queued packet into a provided buffer. ">read()</a>'ing it, or as a zero-copy alternative to <a class="el" href="struct_sifteo_1_1_usb_queue.html#acfa5f04ad70ffc4bce177962a4b85c8b" title="Read the oldest queued packet into a provided buffer. ">read()</a>. </p>

</div>
</div>
<a class="anchor" id="a47942c80131d658ef477f026da9d553e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned tCapacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_sifteo_1_1_usb_queue.html">Sifteo::UsbQueue</a>&lt; tCapacity &gt;::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeue the oldest packet. </p>
<p>This can be called after <a class="el" href="struct_sifteo_1_1_usb_queue.html#a9064ba3d92d5d871a0c39fab1ea18c2b" title="Access the oldest queued packet without copying it. ">peek()</a> to remove the packet from our queue. Must only be called if readAvailable() returns a nonzero value. </p>

</div>
</div>
<a class="anchor" id="acfa5f04ad70ffc4bce177962a4b85c8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned tCapacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_sifteo_1_1_usb_queue.html">Sifteo::UsbQueue</a>&lt; tCapacity &gt;::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sifteo_1_1_usb_packet.html">UsbPacket</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the oldest queued packet into a provided buffer. </p>
<p>Must only be called if readAvailable() returns a nonzero value. If no packets are available, try again later or use an Event to get notified when USB data arrives.</p>
<p>This function copies the data. To read data without copying, use <a class="el" href="struct_sifteo_1_1_usb_queue.html#a9064ba3d92d5d871a0c39fab1ea18c2b" title="Access the oldest queued packet without copying it. ">peek()</a> and <a class="el" href="struct_sifteo_1_1_usb_queue.html#a47942c80131d658ef477f026da9d553e" title="Dequeue the oldest packet. ">pop()</a>. </p>

</div>
</div>
<a class="anchor" id="a9a5cadbf7029711fec8899246687ff2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned tCapacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sifteo_1_1_usb_packet.html">UsbPacket</a>&amp; <a class="el" href="struct_sifteo_1_1_usb_queue.html">Sifteo::UsbQueue</a>&lt; tCapacity &gt;::reserve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a buffer slot where a new packet can be written. </p>
<p>Must only be calld if writeAvailable() returns a nonzero value. If there's no space in the buffer, try again later or use an Event to get notified when more space is available.</p>
<p>This "reserves" space for a new packet, and returns a reference to that space. This doesn't actually affect the state of the queue until <a class="el" href="struct_sifteo_1_1_usb_queue.html#a210ba397133bb0eeb95500953b2ca899" title="Finish writing a packet that was started with reserve() ">commit()</a>, at which point the written packet becomes visible to consumers. </p>

</div>
</div>
<a class="anchor" id="ad9ea7fde0ddb1c4a1ea8fceb0b53f25f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned tCapacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_sifteo_1_1_usb_queue.html">Sifteo::UsbQueue</a>&lt; tCapacity &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sifteo_1_1_usb_packet.html">UsbPacket</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a new packet into the queue, from a provided buffer. </p>
<p>Must only be called if writeAvailable() returns a nonzero value. If there's no space in the buffer, try again later or use an Event to get notified when more space is available.</p>
<p>This function copies the data. To write data without copying, use <a class="el" href="struct_sifteo_1_1_usb_queue.html#a9a5cadbf7029711fec8899246687ff2c" title="Access a buffer slot where a new packet can be written. ">reserve()</a> and <a class="el" href="struct_sifteo_1_1_usb_queue.html#a210ba397133bb0eeb95500953b2ca899" title="Finish writing a packet that was started with reserve() ">commit()</a>. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="usb_8h_source.html">usb.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
    <hr class="footer"/>
    <address class="footer">
        <p><a href="http://sifteo.com">Sifteo</a> SDK v1.1.0 <small>(see <a href="https://developers.sifteo.com/archive">all versions</a>)</small></p>
        <p>Last updated Tue Dec 23 2014, by <a href="http://www.stack.nl/~dimitri/doxygen">Doxygen</a></p>
    </address>
</body>
</html>
